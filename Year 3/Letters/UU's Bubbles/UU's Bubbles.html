<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÂêπÊ≥°Ê≥°ËÆ§Â≠óÊØç - Âø´‰πêÂ≠¶‰π†</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(180deg, #87CEEB 0%, #E0F7FA 100%);
            touch-action: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 10;
        }
        
        #score-board {
            position: absolute;
            top: 30px;
            left: 30px;
            background: rgba(255, 255, 255, 0.9);
            border: 5px solid #FFD700;
            border-radius: 25px;
            padding: 10px 30px;
            display: flex;
            align-items: center;
            gap: 15px;
            box-shadow: 0 8px 0 rgba(218, 165, 32, 0.5), 0 10px 20px rgba(0,0,0,0.1);
            z-index: 30;
            pointer-events: none;
            transition: transform 0.1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            transform-origin: center center;
        }

        .score-icon {
            font-size: 2.5rem;
            animation: spin-slow 8s linear infinite;
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.1));
            cursor: default;
        }

        #scoreDisplay {
            font-family: "Comic Sans MS", "Chalkboard SE", sans-serif;
            font-size: 3.5rem;
            font-weight: 900;
            color: #FF6B6B;
            text-shadow: 3px 3px 0px #fff, 0 0 5px rgba(0,0,0,0.1); 
            line-height: 1;
            min-width: 60px;
            text-align: center;
        }

        /* ËÆ°Êó∂Âô®ÊòæÁ§∫ */
        #timerDisplay {
            position: absolute;
            top: 110px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.8);
            padding: 5px 20px;
            border-radius: 20px;
            font-family: "Comic Sans MS", monospace;
            font-size: 2rem;
            font-weight: bold;
            color: #4A90E2;
            text-shadow: 2px 2px 0px white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            z-index: 25;
            display: none; /* ÂºÄÂßãÂêéÊòæÁ§∫ */
        }

        @keyframes spin-slow {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #controls {
            position: absolute;
            top: 20px;
            right: 30px;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(8px);
            padding: 10px 25px;
            border-radius: 50px;
            display: flex;
            align-items: center;
            gap: 15px;
            font-family: sans-serif;
            color: #4A90E2;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            z-index: 20;
            pointer-events: auto;
            white-space: nowrap;
            width: max-content;
        }
        input[type=range] {
            cursor: pointer;
            accent-color: #FF6B6B;
            width: 80px;
            vertical-align: middle;
        }
        #nameInput {
            width: 70px;
            background: rgba(255, 255, 255, 0.5);
            border: 2px solid #FF6B6B;
            border-radius: 12px;
            padding: 2px 5px;
            color: #FF6B6B;
            font-weight: bold;
            text-align: center;
            outline: none;
            transition: all 0.2s;
            font-family: "Comic Sans MS", sans-serif;
        }
        #nameInput:focus {
            background: white;
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(255, 107, 107, 0.3);
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .divider {
            width: 1px;
            height: 20px;
            background-color: #cbd5e1;
            margin: 0 5px;
        }
        #escapeRateDisplay {
            position: absolute;
            top: 30px;
            left: 30px;
            background: rgba(255, 255, 255, 0.9);
            color: #FF6B6B;
            padding: 10px 20px;
            border-radius: 20px;
            font-family: "Comic Sans MS", sans-serif;
            font-size: 1.2rem;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            z-index: 25;
            display: none;
            border: 3px solid rgba(255, 107, 107, 0.5);
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }
        #escapeRateDisplay.danger {
            background: rgba(255, 50, 50, 0.95);
            color: white;
            border-color: #FF3333;
            animation: pulse 0.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        #settingsBtn {
            position: absolute;
            top: 30px;
            right: 30px;
            background: rgba(255, 255, 255, 0.9);
            border: 4px solid #FFD700;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 1.8rem;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            z-index: 30;
            transition: transform 0.2s;
        }
        #settingsBtn:hover {
            transform: scale(1.1);
        }

        #restartGameBtn {
            position: absolute;
            top: 90px;
            right: 30px;
            background: rgba(255, 255, 255, 0.9);
            border: 4px solid #FFD700;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 1.8rem;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            z-index: 30;
            transition: transform 0.2s;
            display: none;
        }
        #restartGameBtn:hover {
            transform: scale(1.1);
        }
        #restartGameBtn:active {
            transform: scale(0.95);
        }

        #settingsModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }
        #settingsContent {
            background: white;
            border: 8px solid #FFD700;
            border-radius: 40px;
            padding: 40px 60px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 50px rgba(0,0,0,0.3);
            animation: zoomIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .settings-title {
            font-size: 2rem;
            font-weight: 900;
            color: #FF6B6B;
            text-align: center;
            margin-bottom: 30px;
        }
        .settings-group {
            margin-bottom: 25px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
        }
        .settings-label {
            font-size: 1.1rem;
            font-weight: bold;
            color: #4A90E2;
            min-width: 100px;
        }
        .settings-control {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #settingsCloseBtn {
            background: #FF6B6B;
            border: 4px solid white;
            color: white;
            font-size: 1.2rem;
            padding: 12px 30px;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            transition: transform 0.2s;
            width: 100%;
            margin-top: 10px;
        }
        #settingsCloseBtn:hover {
            transform: scale(1.05);
            background: #FF5252;
        }
        #musicBtn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            transition: transform 0.2s;
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.1));
            padding: 0 5px;
        }
        #musicBtn:hover {
            transform: scale(1.1);
        }
        
        .start-btn {
            pointer-events: auto;
            background: #FF6B6B;
            border: 4px solid white;
            color: white;
            font-size: 2rem;
            padding: 1rem 3rem;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            transition: transform 0.2s, background 0.2s;
            animation: bounce 2s infinite;
        }
        .start-btn:disabled {
            background: #bdc3c7;
            animation: none;
            cursor: not-allowed;
            transform: none;
        }
        .start-btn:hover:not(:disabled) {
            transform: scale(1.05);
            background: #FF5252;
        }
        .start-btn:active:not(:disabled) {
            transform: scale(0.95);
        }
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        #instruction {
            position: absolute;
            bottom: 20px;
            color: #4A90E2;
            font-size: 1.2rem;
            font-weight: bold;
            text-shadow: 1px 1px 0px white;
            opacity: 0.8;
            text-align: center;
            width: 100%;
        }
        #loadingText {
            margin-top: 1rem;
            color: #fff;
            font-weight: bold;
            font-size: 1.2rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
        }
        .pop-text {
            position: absolute;
            color: white;
            font-weight: 900;
            font-size: 4rem;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            animation: popUp 1s forwards;
            z-index: 5;
        }
        @keyframes popUp {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1) translateY(-50px); opacity: 0; }
        }

        /* ËÉúÂà©Èù¢ÊùøÊ†∑Âºè */
        #victoryModal {
            display: none; /* ÈªòËÆ§ÈöêËóè */
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            z-index: 100;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.5s;
        }
        #victoryContent {
            background: white;
            border: 8px solid #FFD700;
            border-radius: 40px;
            padding: 40px 60px;
            text-align: center;
            box-shadow: 0 20px 50px rgba(0,0,0,0.3);
            animation: zoomIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            max-width: 90%;
        }
        @keyframes zoomIn {
            from { transform: scale(0.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="score-board" style="left: 50%; transform: translateX(-50%);">
        <div class="score-icon">‚≠ê</div>
        <div id="scoreDisplay">0</div>
    </div>

    <!-- ÈÄÉÈÄ∏ÁéáÊòæÁ§∫ -->
    <div id="escapeRateDisplay">ÈÄÉÈÄ∏Áéá: 0%</div>

    <!-- ËÆæÁΩÆÊåâÈíÆ -->
    <button id="settingsBtn" title="ÊâìÂºÄËÆæÁΩÆ">‚öôÔ∏è</button>

    <!-- ÈáçÊñ∞ÂºÄÂßãÊåâÈíÆ -->
    <button id="restartGameBtn" title="ÈáçÊñ∞ÂºÄÂßãÊ∏∏Êàè">üîÑ</button>

    <!-- ËÆ°Êó∂Âô®ÊòæÁ§∫ -->
    <div id="timerDisplay" style="display: none;">15:00</div>

    <div id="ui-layer">
        <button id="startBtn" class="start-btn" disabled>Âä†ËΩΩ‰∏≠...</button>
        <div id="loadingText">ÂáÜÂ§áÂ≠óÊØçÂ£∞Èü≥... 0/26</div>
        <div id="instruction" class="hidden">
            Êåâ [Á©∫Ê†ºÈîÆ] ÂêπÊ≥°Ê≥°  |  Êåâ [Â≠óÊØçÈîÆ] Êà≥Á†¥Ê≥°Ê≥°
        </div>
    </div>

    <!-- ËÉúÂà©ÁªìÁÆóÁîªÈù¢ -->
    <div id="victoryModal">
        <div id="victoryContent">
            <div style="font-size: 6rem; margin-bottom: 20px;">üèÜ</div>
            <h2 style="font-size: 3rem; font-weight: 900; color: #FF6B6B; margin-bottom: 10px;">Â§™Ê£í‰∫ÜÔºÅ‰ºëÊÅØ‰∏Ä‰ºöÂêß</h2>
            <p style="font-size: 1.5rem; color: #4A90E2; font-weight: bold; margin-bottom: 30px;">
                {name} ‰∏ÄÂÖ±Êî∂ÈõÜ‰∫Ü <span id="finalScore" style="font-size: 3rem; color: #FFD700; margin: 0 10px;">0</span> ‰∏™Ê≥°Ê≥°ÔºÅ
            </p>
            <button id="restartBtn" class="start-btn" style="font-size: 1.5rem; padding: 15px 40px;">ÂÜçÁé©‰∏ÄÊ¨°</button>
        </div>
    </div>

    <!-- Â§±Ë¥•ÁªìÁÆóÁîªÈù¢ -->
    <div id="failModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.6); backdrop-filter: blur(5px); z-index: 100; justify-content: center; align-items: center; animation: fadeIn 0.5s;">
        <div id="failContent" style="background: white; border: 8px solid #FF4444; border-radius: 40px; padding: 40px 60px; text-align: center; box-shadow: 0 20px 50px rgba(0,0,0,0.3); animation: zoomIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); max-width: 90%;">
            <div style="font-size: 6rem; margin-bottom: 20px;">üò¢</div>
            <h2 style="font-size: 3rem; font-weight: 900; color: #FF4444; margin-bottom: 10px;">Ê∏∏ÊàèÂ§±Ë¥•‰∫Ü</h2>
            <p style="font-size: 1.5rem; color: #4A90E2; font-weight: bold; margin-bottom: 30px;">
                {name} ÁöÑÊ≥°Ê≥°ÈÄÉÈÄ∏ÁéáËææÂà∞‰∫Ü <span id="finalEscapeRate" style="font-size: 3rem; color: #FF4444; margin: 0 10px;">0%</span>
            </p>
            <p style="font-size: 1.2rem; color: #888; margin-bottom: 30px;">
                ‰∏ãÊ¨°Ë¶ÅÂø´ÁÇπÊääÊ≥°Ê≥°Êî∂ÈõÜËµ∑Êù•Âì¶ÔºÅ
            </p>
            <button id="retryBtn" class="start-btn" style="font-size: 1.5rem; padding: 15px 40px;">ÂÜçËØï‰∏ÄÊ¨°</button>
        </div>
    </div>

    <!-- ËÆæÁΩÆÈù¢Êùø -->
    <div id="settingsModal">
        <div id="settingsContent">
            <h2 class="settings-title">‚öôÔ∏è Ê∏∏ÊàèËÆæÁΩÆ</h2>

            <div class="settings-group">
                <span class="settings-label">ÂÆùÂÆùÁöÑÂêçÂ≠ó</span>
                <div class="settings-control">
                    <input type="text" id="nameInput" value="ÊÇ†ÊÇ†" maxlength="6" placeholder="ÂêçÂ≠ó" style="width: 100%; padding: 8px 12px; border: 2px solid #FF6B6B; border-radius: 12px; font-size: 1rem; font-weight: bold; color: #FF6B6B; font-family: 'Comic Sans MS', sans-serif; outline: none;">
                </div>
            </div>

            <div class="settings-group">
                <span class="settings-label">Ê∏∏ÊàèÊó∂Èïø</span>
                <div class="settings-control">
                    <input type="range" id="timeSlider" min="1" max="15" step="1" value="15" style="flex: 1;">
                    <span id="timeVal" style="font-weight: bold; color: #4A90E2; min-width: 50px; text-align: center;">15 ÂàÜÈíü</span>
                </div>
            </div>

            <div class="settings-group">
                <span class="settings-label">Ê≥°Ê≥°Êï∞Èáè</span>
                <div class="settings-control">
                    <input type="range" id="countSlider" min="1" max="15" step="1" value="5" style="flex: 1;">
                    <span id="countVal" style="font-weight: bold; color: #4A90E2; min-width: 50px; text-align: center;">5 ‰∏™</span>
                </div>
            </div>

            <div class="settings-group">
                <span class="settings-label">Ê≥°Ê≥°ÈÄüÂ∫¶</span>
                <div class="settings-control">
                    <input type="range" id="speedSlider" min="0.1" max="2.0" step="0.1" value="0.5" style="flex: 1;">
                    <span id="speedVal" style="font-weight: bold; color: #4A90E2; min-width: 50px; text-align: center;">0.5x</span>
                </div>
            </div>

            <div class="settings-group">
                <span class="settings-label">Ê≥°Ê≥°‰∏äÈôê</span>
                <div class="settings-control">
                    <input type="range" id="limitSlider" min="20" max="200" step="10" value="100" style="flex: 1;">
                    <span id="limitVal" style="font-weight: bold; color: #4A90E2; min-width: 50px; text-align: center;">100</span>
                </div>
            </div>

            <div class="settings-group">
                <span class="settings-label">Â§±Ë¥•ÈÄÉÈÄ∏Áéá</span>
                <div class="settings-control">
                    <input type="range" id="escapeRateSlider" min="0" max="101" step="1" value="50" style="flex: 1;">
                    <span id="escapeRateVal" style="font-weight: bold; color: #4A90E2; min-width: 50px; text-align: center;">50%</span>
                </div>
            </div>

            <div class="settings-group" style="justify-content: center;">
                <div class="settings-control" style="justify-content: center;">
                    <button id="musicBtn" title="ËÉåÊôØÈü≥‰πêÂºÄÂÖ≥" style="background: none; border: 2px solid #FFD700; border-radius: 50%; width: 50px; height: 50px; font-size: 1.5rem; cursor: pointer;">üéµ</button>
                </div>
            </div>

            <button id="settingsCloseBtn">‰øùÂ≠òÂπ∂ÂÖ≥Èó≠</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startBtn = document.getElementById('startBtn');
        const loadingText = document.getElementById('loadingText');
        const instruction = document.getElementById('instruction');
        
        const speedSlider = document.getElementById('speedSlider');
        const countSlider = document.getElementById('countSlider');
        const countVal = document.getElementById('countVal');
        const timeSlider = document.getElementById('timeSlider');
        const timeVal = document.getElementById('timeVal');
        const limitSlider = document.getElementById('limitSlider');
        const limitVal = document.getElementById('limitVal');
        const escapeRateSlider = document.getElementById('escapeRateSlider');
        const escapeRateVal = document.getElementById('escapeRateVal');
        const musicBtn = document.getElementById('musicBtn');
        const nameInput = document.getElementById('nameInput');
        const settingsBtn = document.getElementById('settingsBtn');
        const settingsModal = document.getElementById('settingsModal');
        const settingsCloseBtn = document.getElementById('settingsCloseBtn');
        const speedVal = document.getElementById('speedVal');
        
        const scoreDisplay = document.getElementById('scoreDisplay');
        const scoreBoard = document.getElementById('score-board');
        const timerDisplay = document.getElementById('timerDisplay');
        
        const victoryModal = document.getElementById('victoryModal');
        const victoryContent = document.getElementById('victoryContent');
        const finalScoreSpan = document.getElementById('finalScore');
        const restartBtn = document.getElementById('restartBtn');
        const failModal = document.getElementById('failModal');
        const failContent = document.getElementById('failContent');
        const finalEscapeRateSpan = document.getElementById('finalEscapeRate');
        const retryBtn = document.getElementById('retryBtn');
        const escapeRateDisplay = document.getElementById('escapeRateDisplay');
        const restartGameBtn = document.getElementById('restartGameBtn');

        let width, height;
        let bubbles = [];
        let particles = [];
        let ripples = []; 
        let isGameActive = false;
        let score = 0;
        
        let globalSpeedMultiplier = parseFloat(speedSlider.value);
        let spawnQuantity = parseInt(countSlider.value);
        let gameDurationMins = parseInt(timeSlider.value);
        let bubbleLimit = parseInt(limitSlider.value);
        let maxEscapeRate = 50;
        let isSpawning = false;
        let childName = nameInput.value || "ÊÇ†ÊÇ†";

        // ÈÄÉÈÄ∏ÁéáÁªüËÆ°
        let totalBubblesSpawned = 0;
        let escapedBubblesCount = 0;
        let hasStartedTracking = false; // ÊòØÂê¶ÂºÄÂßãÁªüËÆ°ÈÄÉÈÄ∏Áéá
        let trackingStartedTime = 0; // ÂºÄÂßãËøΩË∏™ÁöÑÊó∂Èó¥Êà≥
        
        let blowAnimationEnd = 0;
        let failBlowAnimationEnd = 0; 
        
        // ËÆ°Êó∂Âô®Áõ∏ÂÖ≥ÂèòÈáè
        let timerEndTime = 0;
        let isTimerRunning = false;
        
        let currentPraiseInterval = 5; 
        const maxPraiseInterval = 20; 
        let nextPraiseTarget = 5; 
        
        let currentPraiseUtterance = null;
        let lastPlayedLetterSource = null; 
        
        speedSlider.addEventListener('input', (e) => {
            globalSpeedMultiplier = parseFloat(e.target.value);
            speedVal.innerText = globalSpeedMultiplier.toFixed(1) + 'x';
        });

        countSlider.addEventListener('input', (e) => {
            spawnQuantity = parseInt(e.target.value);
            countVal.innerText = spawnQuantity + ' ‰∏™';
        });

        timeSlider.addEventListener('input', (e) => {
            gameDurationMins = parseInt(e.target.value);
            timeVal.innerText = gameDurationMins + ' ÂàÜÈíü';
            if (!isTimerRunning && !isGameActive) {
                // Â¶ÇÊûúÊ∏∏ÊàèËøòÊ≤°ÂºÄÂßãÔºåÊõ¥Êñ∞ÊòæÁ§∫È¢ÑËßà
                timerDisplay.innerText = `${gameDurationMins.toString().padStart(2, '0')}:00`;
            }
        });

        limitSlider.addEventListener('input', (e) => {
            bubbleLimit = parseInt(e.target.value);
            limitVal.innerText = bubbleLimit;
        });

        escapeRateSlider.addEventListener('input', (e) => {
            maxEscapeRate = parseInt(e.target.value);
            escapeRateVal.innerText = maxEscapeRate + '%';
        });

        settingsBtn.addEventListener('click', () => {
            settingsModal.style.display = 'flex';
        });

        settingsCloseBtn.addEventListener('click', () => {
            settingsModal.style.display = 'none';
        });

        nameInput.addEventListener('keydown', (e) => {
            e.stopPropagation();
        });

        nameInput.addEventListener('input', (e) => {
            childName = e.target.value.trim() || "ÊÇ†ÊÇ†";
        });
        nameInput.addEventListener('keydown', (e) => {
            e.stopPropagation();
        });
        
        let audioCtx;
        let isMusicPlaying = true;
        let musicNextNoteTime = 0;
        let musicTimerID = null;
        let noteIndex = 0;

        // --- Â≠óÊØçÈü≥È¢ëÁ≥ªÁªü ---
        const letterAudioMap = {};
        let loadedCount = 0;

        function getOnlineSoundUrl(letter) {
            const l = letter.toUpperCase();
            return `https://dict.youdao.com/dictvoice?audio=${l}&type=2`;
        }

        function getLocalSoundUrl(letter) {
            return `./sound/${letter.toLowerCase()}.mp3`;
        }

        function preloadSounds() {
            const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
            letters.forEach(letter => {
                const localUrl = getLocalSoundUrl(letter);
                const onlineUrl = getOnlineSoundUrl(letter);

                fetch(localUrl)
                    .then(res => {
                        if (!res.ok) throw new Error("Local missing");
                        return res.arrayBuffer();
                    })
                    .then(buf => {
                        if(audioCtx) return audioCtx.decodeAudioData(buf);
                    })
                    .then(audioBuf => {
                        if(audioBuf) {
                            letterAudioMap[letter] = { type: 'buffer', data: audioBuf };
                            incrementLoad();
                        }
                    })
                    .catch(() => {
                        const audio = new Audio();
                        audio.src = onlineUrl;
                        audio.preload = "auto";
                        letterAudioMap[letter] = { type: 'audio', data: audio };
                        audio.oncanplaythrough = () => { if(!audio.loadedFlag) { audio.loadedFlag=true; incrementLoad(); } };
                        audio.onerror = () => { if(!audio.loadedFlag) { audio.loadedFlag=true; incrementLoad(); } };
                        audio.load();
                    });
            });
        }

        function incrementLoad() {
            loadedCount++;
            loadingText.innerText = `ÂáÜÂ§áÂ≠óÊØçÂ£∞Èü≥... ${loadedCount}/26`;
            if (loadedCount >= 26) {
                onAllSoundsLoaded();
            }
        }

        function onAllSoundsLoaded() {
            startBtn.disabled = false;
            startBtn.innerText = "ÂºÄÂßãÁé©Ê≥°Ê≥°ÔºÅ";
            loadingText.style.display = 'none';
        }

        preloadSounds();

        function warmUpAudio() {
            const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
            letters.forEach(letter => {
                const item = letterAudioMap[letter];
                if (item && item.type === 'audio') {
                    const audio = item.data;
                    audio.muted = true;
                    const p = audio.play();
                    if (p !== undefined) p.then(() => { audio.pause(); audio.currentTime=0; audio.muted=false; }).catch(()=>{});
                }
            });
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        window.addEventListener('resize', resize);
        resize();

        function ensureAudioContext() {
            if (!audioCtx) {
                try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e) {}
            }
            if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
        }

        // --- Èü≥‰πê‰∏éÈü≥Êïà ---
        const NOTES = {
            'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23,
            'G4': 392.00, 'A4': 440.00, 'B4': 493.88, 'C5': 523.25,
            'D5': 587.33, 'E5': 659.25, 'F5': 698.46, 'G5': 783.99
        };
        const MELODY = [
            'C4', 'E4', 'G4', 'C5', 'G4', 'E4',
            'C4', 'F4', 'A4', 'C5', 'A4', 'F4',
            'B4', 'D5', 'G5', 'D5', 'B4', 'G4',
            'C4', 'E4', 'G4', 'C5', 'G4', 'E4'
        ];

        function playMusicNote(note, time) {
            if (!audioCtx || !isMusicPlaying) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine'; 
            osc.frequency.value = NOTES[note];
            gain.gain.setValueAtTime(0, time);
            gain.gain.linearRampToValueAtTime(0.1, time + 0.05); 
            gain.gain.exponentialRampToValueAtTime(0.001, time + 0.5); 
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start(time);
            osc.stop(time + 0.6);
        }

        function scheduler() {
            if (!isGameActive || !isMusicPlaying) return;
            while (musicNextNoteTime < audioCtx.currentTime + 0.1) {
                playMusicNote(MELODY[noteIndex % MELODY.length], musicNextNoteTime);
                musicNextNoteTime += 0.4; 
                noteIndex++;
            }
            musicTimerID = requestAnimationFrame(scheduler);
        }

        function startMusic() {
            ensureAudioContext();
            if (isMusicPlaying) {
                musicNextNoteTime = audioCtx.currentTime + 0.1;
                noteIndex = 0;
                scheduler();
                musicBtn.innerText = "üéµ";
                musicBtn.style.opacity = "1";
            } else {
                musicBtn.innerText = "üîá";
                musicBtn.style.opacity = "0.5";
            }
        }

        // ËÉúÂà©Èü≥ÊïàÔºöÈöÜÈáçÁöÑÂíåÂº¶
        function playVictorySound() {
            if (!audioCtx) return;
            const now = audioCtx.currentTime;
            // C Major Chord Arpeggio + Final Chord
            const sequence = [
                {f: 523.25, t: 0},   // C5
                {f: 659.25, t: 0.1}, // E5
                {f: 783.99, t: 0.2}, // G5
                {f: 1046.50, t: 0.3},// C6
                // Final Chord
                {f: 523.25, t: 0.6, d: 1.5},
                {f: 659.25, t: 0.6, d: 1.5},
                {f: 783.99, t: 0.6, d: 1.5},
                {f: 1046.50, t: 0.6, d: 1.5}
            ];

            sequence.forEach(note => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = note.d ? 'triangle' : 'sine'; // ÁªìÂ∞æÁî®‰∏âËßíÊ≥¢Êõ¥Âìç‰∫Æ
                osc.frequency.value = note.f;

                const start = now + note.t;
                const dur = note.d || 0.2;

                gain.gain.setValueAtTime(0, start);
                gain.gain.linearRampToValueAtTime(0.3, start + 0.05);
                gain.gain.exponentialRampToValueAtTime(0.001, start + dur);

                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start(start);
                osc.stop(start + dur + 0.1);
            });
        }

        // Â§±Ë¥•Èü≥ÊïàÔºö‰ΩéÊ≤âÁöÑÂíåÂº¶
        function playFailSound() {
            if (!audioCtx) return;
            const now = audioCtx.currentTime;
            // ‰∏ãÈôçÁöÑÂíåÂº¶
            const sequence = [
                {f: 392.00, t: 0, d: 0.8},   // G4
                {f: 349.23, t: 0.1, d: 0.8}, // F4
                {f: 329.63, t: 0.2, d: 0.8}, // E4
                {f: 293.66, t: 0.3, d: 0.8}, // D4
                {f: 261.63, t: 0.4, d: 1.0}  // C4
            ];

            sequence.forEach(note => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.value = note.f;

                const start = now + note.t;
                const dur = note.d;

                gain.gain.setValueAtTime(0, start);
                gain.gain.linearRampToValueAtTime(0.2, start + 0.05);
                gain.gain.exponentialRampToValueAtTime(0.001, start + dur);

                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start(start);
                osc.stop(start + dur + 0.1);
            });
        }

        musicBtn.addEventListener('click', () => {
            isMusicPlaying = !isMusicPlaying;
            if (isMusicPlaying) {
                musicBtn.innerText = "üéµ";
                musicBtn.style.opacity = "1";
                musicNextNoteTime = audioCtx.currentTime + 0.1; 
                scheduler();
            } else {
                musicBtn.innerText = "üîá";
                musicBtn.style.opacity = "0.5";
                cancelAnimationFrame(musicTimerID);
            }
        });

        // --- Ê∏∏ÊàèÈü≥Êïà ---
        function playPopSound(letter) {
            if (!audioCtx) return;
            const t = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine';
            const index = (letter || 'A').toUpperCase().charCodeAt(0) - 65;
            const safeIndex = Math.max(0, Math.min(25, index));
            const startFreq = 1046.5 * Math.pow(2, -safeIndex / 12);
            osc.frequency.setValueAtTime(startFreq, t);
            osc.frequency.exponentialRampToValueAtTime(10, t + 0.15);
            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(0.8, t + 0.005); 
            gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1); 
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start(t);
            osc.stop(t + 0.15);
        }

        function playBlowSound() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(100, audioCtx.currentTime);
            osc.frequency.linearRampToValueAtTime(300, audioCtx.currentTime + 0.3);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.3);
        }

        // Âêπ‰∏çÂá∫Ê≥°Ê≥°ÁöÑÂ§±Ë¥•Èü≥Êïà
        function playFailBlowSound() {
            if (!audioCtx) return;
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(150, now);
            osc.frequency.exponentialRampToValueAtTime(50, now + 0.2);
            gain.gain.setValueAtTime(0.08, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start(now);
            osc.stop(now + 0.2);
        }

        function speakLetter(letter) {
            const item = letterAudioMap[letter];
            if (item) {
                if (item.type === 'buffer' && audioCtx) {
                    if (lastPlayedLetterSource) { try { lastPlayedLetterSource.stop(); } catch(e) {} }
                    const source = audioCtx.createBufferSource();
                    source.buffer = item.data;
                    source.connect(audioCtx.destination);
                    lastPlayedLetterSource = source;
                    source.start(0);
                } else if (item.type === 'audio') {
                    const audio = item.data;
                    audio.currentTime = 0;
                    audio.play().catch(e => {});
                }
            } else {
                if ('speechSynthesis' in window) {
                    window.speechSynthesis.cancel(); 
                    const utterance = new SpeechSynthesisUtterance(letter);
                    utterance.lang = 'en-US'; 
                    const voices = window.speechSynthesis.getVoices();
                    const femaleVoice = voices.find(v => v.lang.startsWith('en') && (v.name.includes('Google US English') || v.name.includes('Zira') || v.name.includes('Samantha') || v.name.toLowerCase().includes('female')));
                    if (femaleVoice) utterance.voice = femaleVoice;
                    window.speechSynthesis.speak(utterance);
                }
            }
        }

        // --- Êô∫ËÉΩÂ§∏ËµûÁ≥ªÁªü ---
        let hasNaturalVoice = false;
        let bestLocalVoice = null;
        
        // IndexedDB
        const DB_NAME = 'BubbleGameAudioCache';
        const DB_VERSION = 1;
        const STORE_NAME = 'praises';
        let db = null;

        function initDB() {
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(STORE_NAME)) db.createObjectStore(STORE_NAME);
            };
            request.onsuccess = (event) => { db = event.target.result; };
        }
        
        function getCachedAudio(text, callback) {
            if (!db) { callback(null); return; }
            const transaction = db.transaction([STORE_NAME], "readonly");
            const objectStore = transaction.objectStore(STORE_NAME);
            const request = objectStore.get(text);
            request.onsuccess = (event) => {
                if (request.result) callback(request.result); else callback(null);
            };
            request.onerror = () => callback(null);
        }

        function cacheAudio(text, blob) {
            if (!db) return;
            const transaction = db.transaction([STORE_NAME], "readwrite");
            const objectStore = transaction.objectStore(STORE_NAME);
            objectStore.put(blob, text);
        }

        initDB();

        if ('speechSynthesis' in window) {
            window.speechSynthesis.onvoiceschanged = scanLocalVoices;
            setTimeout(scanLocalVoices, 100);
        }

        function scanLocalVoices() {
             if (!('speechSynthesis' in window)) return;
             const voices = window.speechSynthesis.getVoices();
             let bestScore = -1;
             
             voices.forEach(v => {
                if (v.lang.includes('zh') || v.lang.includes('CN') || v.lang.includes('TW')) {
                    let score = 0;
                    const name = v.name.toLowerCase();
                    if (name.includes('microsoft') && name.includes('natural')) score = 100;
                    else if (name.includes('google')) score = 90;
                    else if (name.includes('apple')) score = 85;
                    else if (name.includes('microsoft')) score = 60;
                    else score = 10;
                    if (v.lang === 'zh-CN') score += 5;
                    if (score > bestScore) {
                        bestScore = score;
                        bestLocalVoice = v;
                    }
                }
            });
            if (bestLocalVoice) hasNaturalVoice = (bestScore >= 80);
        }

        function playMagicSound() {
            if (!audioCtx) return;
            const now = audioCtx.currentTime;
            const notes = [523.25, 659.25, 783.99, 987.77, 1046.50]; 
            notes.forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine'; osc.frequency.value = freq;
                const startTime = now + i * 0.05;
                gain.gain.setValueAtTime(0, startTime);
                gain.gain.linearRampToValueAtTime(0.3, startTime + 0.05);
                gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.5);
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.start(startTime); osc.stop(startTime + 0.5);
            });
        }

        const praiseTemplates = [
            "ÂìáÔºå{name}Â∑≤ÁªèÊî∂ÈõÜ‰∫Ü{n}‰∏™Ê≥°Ê≥°Âï¶ÔºÅ",
            "Â§™Ê£í‰∫ÜÔºå{name}Êî∂ÈõÜ‰∫Ü{n}‰∏™Áæé‰∏ΩÁöÑÊ≥°Ê≥°ÔºÅ",
            "Â•ΩÂéâÂÆ≥Ôºå{name}ËÆ©{n}‰∏™Ê≥°Ê≥°ÂèòÊàê‰∫ÜÁÉüËä±ÔºÅ",
            "{name}ÁúüÊ£íÔºåÊàë‰ª¨Â∑≤ÁªèËÆ§ËØÜ‰∫Ü{n}‰∏™Ê≥°Ê≥°ÊúãÂèãÔºÅ",
            "Âä†Ê≤πÂä†Ê≤πÔºå{name}Â∑≤ÁªèÊî∂ÈõÜ‰∫Ü{n}‰∏™Ê≥°Ê≥°Âï¶ÔºÅ",
            "{name}ÂÅöÂæóÂ•ΩÔºå‰Ω†Â∑≤ÁªèÊî∂ÈõÜ‰∫Ü{n}‰∏™Ê≥°Ê≥°ÔºÅ"
        ];

        const tooManyBubblesTemplates = [
            "{name}ÔºåÊ≥°Ê≥°Â§™Â§ö‰∫ÜÔºåÂÖàÊääÂ±èÂπï‰∏äÁöÑÊ≥°Ê≥°Êî∂ÈõÜÂÆåÂêßÔºÅ",
            "ÂìáÔºåÊ≥°Ê≥°ÈÉΩË¶ÅË∑ëÂÖâÂï¶ÔºÅ{name}Âø´ÊääÂÆÉ‰ª¨Êî∂ÈõÜËµ∑Êù•ÔºÅ",
            "{name}ÔºåÂÖàÊääÁé∞ÊúâÁöÑÊ≥°Ê≥°Êà≥Á†¥ÔºåÁÑ∂ÂêéÂÜçÂêπÊñ∞ÁöÑÂêßÔºÅ",
            "Ê≥°Ê≥°Â§™Â§öÂï¶Ôºå{name}ÂÖàÊääÂÆÉ‰ª¨Êî∂ÈõÜÂÆåÂêßÔºÅ"
        ];

        function speakPraise(count) {
            playMagicSound();
            const templateIndex = Math.floor(Math.random() * praiseTemplates.length);
            const template = praiseTemplates[templateIndex];
            const text = template.replace("{n}", count).replace("{name}", childName);

            const localPraiseUrl = `./sound/praise_${templateIndex}.mp3`;
            fetch(localPraiseUrl)
                .then(res => { if (!res.ok) throw new Error("Local praise missing"); return res.blob(); })
                .then(blob => {
                    const url = URL.createObjectURL(blob);
                    const audio = new Audio(url);
                    audio.play();
                })
                .catch(() => { playFallbackPraise(text); });
        }

        function playFallbackPraise(text) {
            getCachedAudio(text, (blob) => {
                if (blob) {
                    const url = URL.createObjectURL(blob);
                    const audio = new Audio(url);
                    audio.play().catch(e => console.error("Cache play failed", e));
                    return;
                }
                if (hasNaturalVoice && bestLocalVoice) { speakNativeTTS(text); return; }
                const encodedText = encodeURIComponent(text);
                const audioSources = [
                    `https://fanyi.sogou.com/reventondc/synthesis?text=${encodedText}&speed=1&lang=zh-CHS&from=translateweb&speaker=6`,
                    `https://dict.youdao.com/dictvoice?audio=${encodedText}&le=zh`
                ];
                tryFetchAndCache(audioSources, 0, text);
            });
        }

        function tryFetchAndCache(sources, index, text) {
            if (index >= sources.length) { speakNativeTTS(text); return; }
            const url = sources[index];
            fetch(url)
                .then(response => { if (!response.ok) throw new Error("Network error"); return response.blob(); })
                .then(blob => {
                    const audioUrl = URL.createObjectURL(blob);
                    const audio = new Audio(audioUrl);
                    audio.play().catch(e => console.error("Play failed", e));
                    cacheAudio(text, blob);
                })
                .catch(err => { tryDirectPlay(url, sources, index, text); });
        }

        function tryDirectPlay(url, sources, index, text) {
            const audio = new Audio(url);
            const timeoutId = setTimeout(() => { audio.src = ""; tryFetchAndCache(sources, index + 1, text); }, 1000);
            audio.oncanplaythrough = () => { clearTimeout(timeoutId); audio.play().catch(() => {}); };
            audio.onerror = () => { clearTimeout(timeoutId); tryFetchAndCache(sources, index + 1, text); };
        }

        function speakNativeTTS(text) {
            if (!('speechSynthesis' in window)) return;
            window.speechSynthesis.cancel(); 
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'zh-CN'; 
            currentPraiseUtterance = utterance; 
            utterance.onend = function() { currentPraiseUtterance = null; };
            if (bestLocalVoice) {
                utterance.voice = bestLocalVoice;
                if (hasNaturalVoice) { utterance.rate = 1.0; utterance.pitch = 1.0; } 
                else { utterance.rate = 0.95; utterance.pitch = 1.1; }
            }
            window.speechSynthesis.speak(utterance);
        }

        // --- Ê∏∏ÊàèÂØπË±° ---

        class Bubble {
            constructor(letter, startX, startY) {
                this.r = 30 + Math.random() * 40;
                this.x = startX !== undefined ? startX : Math.random() * width;
                this.y = startY !== undefined ? startY : height + this.r;
                this.baseSpeed = 1 + Math.random() * 2;
                if (startX !== undefined) this.vx = (Math.random() - 0.5) * 8;
                else this.vx = 0;
                this.sway = Math.random() * 0.05;
                this.swayOffset = Math.random() * Math.PI * 2;
                this.colorHue = Math.random() * 360;
                this.letter = letter || String.fromCharCode(65 + Math.floor(Math.random() * 26));
                this.popped = false;
                this.createdAt = Date.now(); // ËÆ∞ÂΩïÂàõÂª∫Êó∂Èó¥
            }

            update() {
                this.y -= this.baseSpeed * globalSpeedMultiplier;
                if (this.vx !== 0) { this.x += this.vx; this.vx *= 0.98; }
                this.x += Math.sin(this.y * this.sway + this.swayOffset) * 1.5;

                if (this.x - this.r < 0) { this.x = this.r; this.vx = Math.abs(this.vx) * 0.5 + 0.5; }
                else if (this.x + this.r > width) { this.x = width - this.r; this.vx = -Math.abs(this.vx) * 0.5 - 0.5; }

                // Ê≥°Ê≥°ÈÄÉÈÄ∏
                if (this.y < -this.r * 2) {
                    this.popped = true;
                    // Âè™ÊúâÂú®ÂºÄÂßãËøΩË∏™ÂêéÂàõÂª∫ÁöÑÊ≥°Ê≥°ÊâçËÆ°ÂÖ•ÈÄÉÈÄ∏Áéá
                    if (hasStartedTracking && this.createdAt >= trackingStartedTime) {
                        escapedBubblesCount++;
                    }
                    updateEscapeRateDisplay();
                    return false;
                }
                return true;
            }

            draw() {
                ctx.save();
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                ctx.fillStyle = `hsla(${this.colorHue}, 100%, 75%, 0.4)`;
                ctx.fill();
                ctx.strokeStyle = `hsla(${this.colorHue}, 100%, 85%, 0.8)`;
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(this.x - this.r * 0.3, this.y - this.r * 0.3, this.r * 0.2, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.font = `bold ${this.r}px "Comic Sans MS", "Verdana", sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = 'rgba(0,0,0,0.3)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                ctx.fillText(this.letter, this.x, this.y + this.r * 0.1);
                ctx.restore();
            }
        }

        class Ripple {
            constructor(x, y, hue) {
                this.x = x; this.y = y; this.r = 10; this.hue = hue;
                this.opacity = 0.8; this.life = 1.0;
            }
            update() { this.r += 4; this.opacity -= 0.04; this.life -= 0.04; }
            draw() {
                ctx.save();
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                ctx.strokeStyle = `hsla(${this.hue}, 100%, 80%, ${this.opacity})`;
                ctx.lineWidth = 5 * this.life;
                ctx.stroke();
                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, hue, shapeType) {
                this.x = x; this.y = y; this.shapeType = shapeType; 
                this.hue = hue; this.life = 1.0; this.size = Math.random() * 6 + 3;
                const angle = Math.random() * Math.PI * 2; let speed = Math.random() * 6 + 2;
                switch(shapeType) {
                    case 0: this.vx = (Math.random() - 0.5) * 6; this.vy = (Math.random() - 1) * 10 - 2; this.gravity = 0.5; this.drag = 0.98; this.decay = 0.02; break;
                    case 1: speed = Math.random() * 8 + 4; this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed; this.gravity = 0.1; this.drag = 0.95; this.decay = 0.015; break;
                    case 2: speed = Math.random() * 4 + 1; this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed; this.gravity = 0.05; this.drag = 0.90; this.decay = 0.01; this.swayPhase = Math.random() * Math.PI * 2; break;
                    case 3: speed = Math.random() * 5 + 2; this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed; this.gravity = 0; this.drag = 0.97; this.decay = 0.02; break;
                    case 4: this.vx = (Math.random() - 0.5) * 4; this.vy = (Math.random() - 0.5) * 4 - 2; this.gravity = -0.05; this.drag = 0.95; this.decay = 0.015; break;
                    default: this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed; break;
                }
                this.rotation = Math.random() * Math.PI * 2; this.rotationSpeed = (Math.random() - 0.5) * 0.2;
            }
            update() {
                if (this.shapeType === 2) this.x += Math.sin(this.life * 10 + this.swayPhase) * 1.5;
                if (this.shapeType === 3) { const s = 0.15; const oldVx = this.vx; this.vx = this.vx * Math.cos(s) - this.vy * Math.sin(s); this.vy = oldVx * Math.sin(s) + this.vy * Math.cos(s); }
                this.x += this.vx; this.y += this.vy;
                this.vx *= this.drag; this.vy *= this.drag; this.vy += this.gravity;
                this.life -= this.decay; this.size *= 0.96; this.rotation += this.rotationSpeed;
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y); ctx.rotate(this.rotation);
                ctx.globalAlpha = this.life; ctx.globalCompositeOperation = 'lighter';
                ctx.fillStyle = `hsl(${this.hue}, 100%, 70%)`;
                switch(this.shapeType) {
                    case 1: this.drawStar(0, 0, 5, this.size, this.size/2); break;
                    case 2: ctx.fillRect(-this.size, -this.size, this.size*2, this.size*2); break;
                    case 3: this.drawTriangle(0, 0, this.size); break;
                    case 4: this.drawHeart(0, 0, this.size); break;
                    default: ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI * 2); ctx.fill(); break;
                }
                ctx.restore();
            }
            drawTriangle(cx, cy, size) { ctx.beginPath(); ctx.moveTo(0, -size); ctx.lineTo(size, size); ctx.lineTo(-size, size); ctx.closePath(); ctx.fill(); }
            drawHeart(cx, cy, size) { const s = size * 0.8; ctx.beginPath(); ctx.moveTo(0, 0); ctx.bezierCurveTo(s/2, -s/2, s*2, s/3, 0, s*1.5); ctx.bezierCurveTo(-s*2, s/3, -s/2, -s/2, 0, 0); ctx.fill(); }
            drawStar(cx, cy, spikes, outerRadius, innerRadius) { let rot = Math.PI / 2 * 3; let x = cx; let y = cy; let step = Math.PI / spikes; ctx.beginPath(); ctx.moveTo(cx, cy - outerRadius); for (let i = 0; i < spikes; i++) { x = cx + Math.cos(rot) * outerRadius; y = cy + Math.sin(rot) * outerRadius; ctx.lineTo(x, y); rot += step; x = cx + Math.cos(rot) * innerRadius; y = cy + Math.sin(rot) * innerRadius; ctx.lineTo(x, y); rot += step; } ctx.lineTo(cx, cy - outerRadius); ctx.closePath(); ctx.fill(); }
        }

        // --- ‰øÆÂ§ç: drawWand ÂáΩÊï∞Ë°•ÂÖ® ---
        function drawWand() {
            const centerX = width / 2;
            const bottomY = height + 10;
            let scale = 1; let wobble = 0; const now = Date.now();
            if (now < blowAnimationEnd) {
                const progress = (blowAnimationEnd - now) / 500;
                scale = 1 + Math.sin(progress * Math.PI) * 0.2;
                wobble = Math.sin(progress * Math.PI * 8) * 0.05;
            } else if (now < failBlowAnimationEnd) {
                // ÂêπÊ≥°Ê≥°Â§±Ë¥•ÁöÑÂä®ÁîªÔºöÊ≥°Ê≥°Ê£íÊôÉÂä®
                const progress = (failBlowAnimationEnd - now) / 300;
                wobble = Math.sin(progress * Math.PI * 12) * 0.15 * progress;
                scale = 1 - progress * 0.1;
            }
            ctx.save(); ctx.translate(centerX, bottomY); ctx.rotate(wobble); ctx.scale(scale, scale);
            ctx.fillStyle = '#FF8A80'; ctx.beginPath(); ctx.roundRect(-8, -150, 16, 160, 8); ctx.fill();
            ctx.strokeStyle = 'white'; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(-4, -140); ctx.lineTo(-4, -20); ctx.stroke();
            ctx.translate(0, -150);
            ctx.beginPath(); ctx.arc(0, 0, 45, 0, Math.PI * 2); ctx.strokeStyle = '#FF5252'; ctx.lineWidth = 12; ctx.stroke();
            ctx.beginPath(); ctx.arc(-20, -20, 10, Math.PI, 1.5 * Math.PI); ctx.strokeStyle = 'rgba(255,255,255,0.6)'; ctx.lineWidth = 4; ctx.stroke();
            if (now < blowAnimationEnd) { ctx.beginPath(); ctx.arc(0, 0, 38, 0, Math.PI * 2); ctx.fillStyle = 'rgba(200, 240, 255, 0.4)'; ctx.fill(); }
            ctx.restore();
        }

        // ÈáçÊñ∞ÂºÄÂßãÊ∏∏ÊàèÂáΩÊï∞
        function restartGame() {
            isGameActive = false;
            isTimerRunning = false;
            cancelAnimationFrame(musicTimerID);

            bubbles = [];
            particles = [];
            ripples = [];
            score = 0;
            scoreDisplay.innerText = 0;

            // ÈáçÁΩÆËÆ°Êó∂Âô®Áä∂ÊÄÅ
            isTimerRunning = false;
            timerEndTime = 0;

            // ÈáçÁΩÆÈÄÉÈÄ∏ÁéáÁªüËÆ°
            totalBubblesSpawned = 0;
            escapedBubblesCount = 0;
            hasStartedTracking = false;
            updateEscapeRateDisplay();

            startGame();
        }

        function startGame() {
            if (isGameActive) return;
            startBtn.style.display = 'none';
            instruction.classList.remove('hidden');
            instruction.style.display = 'block';
            timerDisplay.style.display = 'block';
            timerDisplay.innerText = `${gameDurationMins.toString().padStart(2, '0')}:00`;
            escapeRateDisplay.style.display = 'block';
            restartGameBtn.style.display = 'block';

            isGameActive = true;
            score = 0;
            scoreDisplay.innerText = 0;

            // ÈáçÁΩÆËÆ°Êó∂Âô®Áä∂ÊÄÅ
            isTimerRunning = false;
            timerEndTime = 0;

            // ÈáçÁΩÆÈÄÉÈÄ∏ÁéáÁªüËÆ°
            totalBubblesSpawned = 0;
            escapedBubblesCount = 0;
            hasStartedTracking = false; // ÈáçÁΩÆÈÄÉÈÄ∏ÁéáÁªüËÆ°Ê†áÂøó
            updateEscapeRateDisplay();

            ensureAudioContext();
            startMusic();
            scanLocalVoices();
            warmUpAudio();
            spawnBubbles(spawnQuantity);
            gameLoop();
        }

        // ÁªìÊùüÊ∏∏ÊàèÂáΩÊï∞
        function endGame() {
            isGameActive = false;
            isTimerRunning = false;
            cancelAnimationFrame(musicTimerID); // ÂÅúÊ≠¢Èü≥‰πê

            // ÊòæÁ§∫ËÉúÂà©ÁîªÈù¢
            victoryContent.querySelector('p').innerHTML = `${childName} ‰∏ÄÂÖ±Êî∂ÈõÜ‰∫Ü <span id="finalScore" style="font-size: 3rem; color: #FFD700; margin: 0 10px;">${score}</span> ‰∏™Ê≥°Ê≥°ÔºÅ`;
            victoryModal.style.display = 'flex';

            // Êí≠ÊîæËÉúÂà©Èü≥ÊïàÂíåËØ≠Èü≥
            playVictorySound();
            speakPraise(score);
        }

        // Ê∏∏ÊàèÂ§±Ë¥•ÂáΩÊï∞
        function failGame() {
            isGameActive = false;
            isTimerRunning = false;
            cancelAnimationFrame(musicTimerID); // ÂÅúÊ≠¢Èü≥‰πê

            // ËÆ°ÁÆóÊúÄÁªàÈÄÉÈÄ∏Áéá
            const finalRate = totalBubblesSpawned > 0 ? Math.round((escapedBubblesCount / totalBubblesSpawned) * 100) : 0;

            // ÊòæÁ§∫Â§±Ë¥•ÁîªÈù¢
            failContent.querySelector('p').innerHTML = `${childName} ÁöÑÊ≥°Ê≥°ÈÄÉÈÄ∏ÁéáËææÂà∞‰∫Ü <span id="finalEscapeRate" style="font-size: 3rem; color: #FF4444; margin: 0 10px;">${finalRate}%</span>`;
            failModal.style.display = 'flex';

            // Êí≠ÊîæÂ§±Ë¥•Èü≥Êïà
            playFailSound();
        }

        // ÈáçÁΩÆÂπ∂ÈáçÊñ∞ÂºÄÂßã
        restartBtn.addEventListener('click', () => {
            victoryModal.style.display = 'none';
            restartGame();
        });

        // Â§±Ë¥•ÂêéÈáçÊñ∞ÂºÄÂßã
        retryBtn.addEventListener('click', () => {
            failModal.style.display = 'none';
            restartGame();
        });

        function spawnBubbles(count) {
            // Ê£ÄÊü•Ê≥°Ê≥°Êï∞ÈáèÊòØÂê¶Ë∂ÖËøá‰∏äÈôê
            const activeBubbles = bubbles.filter(b => !b.popped);
            if (activeBubbles.length + count > bubbleLimit) {
                // ÂêπÊ≥°Ê≥°Â§±Ë¥•
                playFailBlowSound();
                failBlowAnimationEnd = Date.now() + 300;
                // ËØ≠Èü≥ÊèêÁ§∫
                const templateIndex = Math.floor(Math.random() * tooManyBubblesTemplates.length);
                const template = tooManyBubblesTemplates[templateIndex];
                const text = template.replace("{name}", childName);

                const localTooManyUrl = `./sound/toomany_${templateIndex}.mp3`;
                fetch(localTooManyUrl)
                    .then(res => { if (!res.ok) throw new Error("Local too-many missing"); return res.blob(); })
                    .then(blob => {
                        const url = URL.createObjectURL(blob);
                        const audio = new Audio(url);
                        audio.play();
                    })
                    .catch(() => { playFallbackPraise(text); });
                return false;
            }

            // Ê≠£Â∏∏ÂêπÊ≥°Ê≥°
            isSpawning = true;
            playBlowSound();
            blowAnimationEnd = Date.now() + 800;
            const startX = width / 2;
            const startY = height - 140;
            for (let i = 0; i < count; i++) {
                setTimeout(() => {
                    const activeLetters = new Set(bubbles.filter(b => !b.popped).map(b => b.letter));
                    const allLetters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
                    const available = allLetters.filter(l => !activeLetters.has(l));
                    let finalLetter = available.length > 0 ? available[Math.floor(Math.random() * available.length)] : allLetters[Math.floor(Math.random() * allLetters.length)];
                    const newBubble = new Bubble(finalLetter, startX, startY);
                    bubbles.push(newBubble);
                    // Âè™ÊúâÂú®ÂºÄÂßãËøΩË∏™ÂêéÂêπÂá∫ÁöÑÊ≥°Ê≥°ÊâçËÆ°ÂÖ•ÊÄªÊï∞
                    if (hasStartedTracking && newBubble.createdAt >= trackingStartedTime) {
                        totalBubblesSpawned++;
                    }
                    if (i === 0) isSpawning = false;
                }, i * 60);
            }
            return true;
        }

        function popBubble(letter) {
            const candidates = bubbles.filter(b => b.letter === letter && !b.popped);
            if (candidates.length > 0) {
                // --- ËÆ°Êó∂Âô®ÈÄªËæë ---
                if (!isTimerRunning) {
                    isTimerRunning = true;
                    // ËÆæÁΩÆÁªìÊùüÊó∂Èó¥ = ÂΩìÂâçÊó∂Èó¥ + ÂàÜÈíüÊï∞ * 60000
                    timerEndTime = Date.now() + gameDurationMins * 60 * 1000;
                }

                // --- ÂºÄÂßãÁªüËÆ°ÈÄÉÈÄ∏Áéá ---
                if (!hasStartedTracking) {
                    hasStartedTracking = true;
                    trackingStartedTime = Date.now();
                    // ‰∏çÂ∞ÜÂ±èÂπï‰∏äÂ∑≤ÊúâÁöÑÊ≥°Ê≥°ËÆ°ÂÖ•ÈÄÉÈÄ∏ÁéáÁªüËÆ°Ôºå‰ªé0ÂºÄÂßã
                    totalBubblesSpawned = 0;
                    escapedBubblesCount = 0;
                }

                // ÂêåÊó∂Êà≥Á†¥ÊâÄÊúâÁõ∏ÂêåÂ≠óÊØçÁöÑÊ≥°Ê≥°
                candidates.forEach(target => {
                    target.popped = true;
                    score++;
                    scoreDisplay.innerText = score;
                    scoreBoard.style.transform = "translateX(-50%) scale(1.2)";
                    setTimeout(() => scoreBoard.style.transform = "translateX(-50%) scale(1)", 150);
                    ripples.push(new Ripple(target.x, target.y, target.colorHue));
                    const charCode = target.letter.charCodeAt(0);
                    const shapeType = (charCode - 65) % 5;
                    for (let i = 0; i < 25; i++) { particles.push(new Particle(target.x, target.y, target.colorHue, shapeType)); }
                    showFloatingText(target.letter, target.x, target.y);
                    playPopSound(target.letter);
                });

                // Â≠óÊØçËØªÈü≥Âè™Êí≠Êîæ‰∏ÄÊ¨°
                speakLetter(letter);

                if (score >= nextPraiseTarget) {
                    speakPraise(nextPraiseTarget);
                    if (currentPraiseInterval < maxPraiseInterval) currentPraiseInterval += 5;
                    nextPraiseTarget += currentPraiseInterval;
                }
                return true;
            }
            return false;
        }

        // Êõ¥Êñ∞ÈÄÉÈÄ∏ÁéáÊòæÁ§∫
        function updateEscapeRateDisplay() {
            // Âè™ÊúâÂºÄÂßãËøΩË∏™ÂêéÊâçÊòæÁ§∫ÈÄÉÈÄ∏Áéá
            if (!hasStartedTracking) {
                escapeRateDisplay.innerText = `ÈÄÉÈÄ∏Áéá: 0%`;
                escapeRateDisplay.style.background = 'rgba(255, 255, 255, 0.9)';
                escapeRateDisplay.style.color = '#FF6B6B';
                escapeRateDisplay.style.borderColor = 'rgba(255, 107, 107, 0.5)';
                escapeRateDisplay.classList.remove('danger');
                return;
            }

            const rate = totalBubblesSpawned > 0 ? Math.round((escapedBubblesCount / totalBubblesSpawned) * 100) : 0;
            escapeRateDisplay.innerText = `ÈÄÉÈÄ∏Áéá: ${rate}%`;

            // ËÆ°ÁÆóÈ¢úËâ≤ËøáÊ∏°ÔºöÁôΩËâ≤(0%) -> Á∫¢Ëâ≤(maxEscapeRate%)
            const ratio = Math.min(rate / maxEscapeRate, 1);
            const r = 255;
            const g = Math.round(255 * (1 - ratio));
            const b = Math.round(255 * (1 - ratio));

            // ËÉåÊôØËâ≤‰ªéÁôΩËâ≤Ê∏êÂèòÂà∞Á∫¢Ëâ≤
            const bgOpacity = 0.9;
            escapeRateDisplay.style.background = `rgba(${r}, ${g}, ${b}, ${bgOpacity})`;

            // ÊñáÂ≠óÈ¢úËâ≤ÔºöÊµÖÁ∫¢Ëâ≤ -> ÁôΩËâ≤
            if (ratio > 0.5) {
                escapeRateDisplay.style.color = 'white';
            } else {
                escapeRateDisplay.style.color = '#FF6B6B';
            }

            // ËæπÊ°ÜÈ¢úËâ≤
            escapeRateDisplay.style.borderColor = `rgba(255, ${Math.round(107 * (1 - ratio))}, ${Math.round(107 * (1 - ratio))}, 0.8)`;

            // Â¶ÇÊûúÈÄÉÈÄ∏ÁéáÊé•Ëøë‰∏äÈôêÔºåÊ∑ªÂä†Âç±Èô©Âä®Áîª
            if (rate >= maxEscapeRate * 0.8) {
                escapeRateDisplay.classList.add('danger');
            } else {
                escapeRateDisplay.classList.remove('danger');
            }

            // Ê£ÄÊü•ÊòØÂê¶ËææÂà∞Â§±Ë¥•Êù°‰ª∂
            if (totalBubblesSpawned > 0 && rate >= maxEscapeRate) {
                failGame();
            }
        }

        function showFloatingText(text, x, y) {
            const el = document.createElement('div'); el.className = 'pop-text'; el.innerText = text;
            el.style.left = x + 'px'; el.style.top = y + 'px'; document.body.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }

        function gameLoop() {
            if (!isGameActive) return;
            
            // --- Êõ¥Êñ∞ËÆ°Êó∂Âô® ---
            if (isTimerRunning) {
                const remaining = timerEndTime - Date.now();
                if (remaining <= 0) {
                    timerDisplay.innerText = "00:00";
                    endGame();
                    return; // ÂÅúÊ≠¢Âæ™ÁéØ
                } else {
                    // Ê†ºÂºèÂåñÊó∂Èó¥ MM:SS
                    const totalSecs = Math.ceil(remaining / 1000);
                    const mins = Math.floor(totalSecs / 60);
                    const secs = totalSecs % 60;
                    timerDisplay.innerText = `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                }
            }

            const activeBubbles = bubbles.filter(b => !b.popped);
            if (activeBubbles.length === 0 && !isSpawning) {
                isSpawning = true; 
                setTimeout(() => {
                    const currentActive = bubbles.filter(b => !b.popped);
                    if(currentActive.length === 0) spawnBubbles(spawnQuantity);
                    else isSpawning = false;
                }, 500);
            }
            ctx.clearRect(0, 0, width, height);
            drawWand();
            for (let i = bubbles.length - 1; i >= 0; i--) { const b = bubbles[i]; const keep = b.update(); if (!keep || b.popped) bubbles.splice(i, 1); else b.draw(); }
            for (let i = ripples.length - 1; i >= 0; i--) { const r = ripples[i]; r.update(); if (r.life <= 0) ripples.splice(i, 1); else r.draw(); }
            for (let i = particles.length - 1; i >= 0; i--) { const p = particles[i]; p.update(); if (p.life <= 0) particles.splice(i, 1); else p.draw(); }
            requestAnimationFrame(gameLoop);
        }

        startBtn.addEventListener('click', startGame);

        // ÈáçÊñ∞ÂºÄÂßãÊåâÈíÆ‰∫ã‰ª∂
        restartGameBtn.addEventListener('click', () => {
            restartGame();
        });

        window.addEventListener('keydown', (e) => {
            if (!isGameActive && e.code === 'Space' && !startBtn.disabled && victoryModal.style.display !== 'flex') { e.preventDefault(); startGame(); return; }
            if (!isGameActive) return;
            if (e.code === 'Space') { e.preventDefault(); spawnBubbles(spawnQuantity); }
            const key = e.key.toUpperCase();
            if (key.length === 1 && key >= 'A' && key <= 'Z') popBubble(key);
        });
        startBtn.addEventListener('click', startGame);
        window.addEventListener('touchstart', (e) => {
            if(!isGameActive) return;
            if(e.target === nameInput) return;
            if(!e.target.closest('#controls') && e.target !== startBtn) spawnBubbles(spawnQuantity); 
        });
    </script>
</body>
</html>