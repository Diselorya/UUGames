<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÂêπÊ≥°Ê≥°ËÆ§Â≠óÊØç - Âø´‰πêÂ≠¶‰π†</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(180deg, #87CEEB 0%, #E0F7FA 100%);
            touch-action: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 10;
        }
        
        #score-board {
            position: absolute;
            top: 30px;
            left: 30px;
            background: rgba(255, 255, 255, 0.9);
            border: 5px solid #FFD700;
            border-radius: 25px;
            padding: 10px 30px;
            display: flex;
            align-items: center;
            gap: 15px;
            box-shadow: 0 8px 0 rgba(218, 165, 32, 0.5), 0 10px 20px rgba(0,0,0,0.1);
            z-index: 30;
            pointer-events: none;
            transition: transform 0.1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            transform-origin: center center;
        }

        .score-icon {
            font-size: 2.5rem;
            animation: spin-slow 8s linear infinite;
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.1));
            cursor: default;
        }

        #scoreDisplay {
            font-family: "Comic Sans MS", "Chalkboard SE", sans-serif;
            font-size: 3.5rem;
            font-weight: 900;
            color: #FF6B6B;
            text-shadow: 3px 3px 0px #fff, 0 0 5px rgba(0,0,0,0.1); 
            line-height: 1;
            min-width: 60px;
            text-align: center;
        }

        @keyframes spin-slow {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #controls {
            position: absolute;
            top: 20px;
            right: 30px;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(8px);
            padding: 10px 25px;
            border-radius: 50px;
            display: flex;
            align-items: center;
            gap: 15px;
            font-family: sans-serif;
            color: #4A90E2;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            z-index: 20;
            pointer-events: auto;
            white-space: nowrap;
            width: max-content;
        }
        input[type=range] {
            cursor: pointer;
            accent-color: #FF6B6B;
            width: 80px;
            vertical-align: middle;
        }
        #nameInput {
            width: 70px;
            background: rgba(255, 255, 255, 0.5);
            border: 2px solid #FF6B6B;
            border-radius: 12px;
            padding: 2px 5px;
            color: #FF6B6B;
            font-weight: bold;
            text-align: center;
            outline: none;
            transition: all 0.2s;
            font-family: "Comic Sans MS", sans-serif;
        }
        #nameInput:focus {
            background: white;
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(255, 107, 107, 0.3);
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .divider {
            width: 1px;
            height: 20px;
            background-color: #cbd5e1;
            margin: 0 5px;
        }
        #musicBtn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            transition: transform 0.2s;
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.1));
            padding: 0 5px;
        }
        #musicBtn:hover {
            transform: scale(1.1);
        }
        
        .start-btn {
            pointer-events: auto;
            background: #FF6B6B;
            border: 4px solid white;
            color: white;
            font-size: 2rem;
            padding: 1rem 3rem;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            transition: transform 0.2s, background 0.2s;
            animation: bounce 2s infinite;
        }
        .start-btn:disabled {
            background: #bdc3c7;
            animation: none;
            cursor: not-allowed;
            transform: none;
        }
        .start-btn:hover:not(:disabled) {
            transform: scale(1.05);
            background: #FF5252;
        }
        .start-btn:active:not(:disabled) {
            transform: scale(0.95);
        }
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        #instruction {
            position: absolute;
            bottom: 20px;
            color: #4A90E2;
            font-size: 1.2rem;
            font-weight: bold;
            text-shadow: 1px 1px 0px white;
            opacity: 0.8;
            text-align: center;
            width: 100%;
        }
        #loadingText {
            margin-top: 1rem;
            color: #fff;
            font-weight: bold;
            font-size: 1.2rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
        }
        .pop-text {
            position: absolute;
            color: white;
            font-weight: 900;
            font-size: 4rem;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            animation: popUp 1s forwards;
            z-index: 5;
        }
        @keyframes popUp {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1) translateY(-50px); opacity: 0; }
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="score-board">
        <div class="score-icon">‚≠ê</div>
        <div id="scoreDisplay">0</div>
    </div>

    <div id="controls">
        <div class="control-group">
            <label for="nameInput" title="ÂÆùÂÆùÁöÑÂêçÂ≠ó" style="font-size: 0.9em;">ÊàëÊòØ</label>
            <input type="text" id="nameInput" value="ÊÇ†ÊÇ†" maxlength="6" placeholder="ÂêçÂ≠ó">
        </div>

        <div class="divider"></div>

        <div class="control-group">
            <label for="countSlider" title="ÊØèÊ¨°ÂêπÊ≥°Ê≥°ÁöÑÊï∞Èáè">Êï∞Èáè</label>
            <input type="range" id="countSlider" min="1" max="15" step="1" value="5">
            <span id="countVal" class="text-xs text-gray-500 w-4">5</span>
        </div>
        
        <div class="divider"></div>

        <div class="control-group">
            <label for="speedSlider">ÈÄüÂ∫¶</label>
            <input type="range" id="speedSlider" min="0.1" max="2.0" step="0.1" value="0.5">
        </div>

        <div class="divider"></div>

        <button id="musicBtn" title="ËÉåÊôØÈü≥‰πêÂºÄÂÖ≥">üéµ</button>
    </div>

    <div id="ui-layer">
        <button id="startBtn" class="start-btn" disabled>Âä†ËΩΩ‰∏≠...</button>
        <div id="loadingText">ÂáÜÂ§áÂ≠óÊØçÂ£∞Èü≥... 0/26</div>
        <div id="instruction" class="hidden">
            Êåâ [Á©∫Ê†ºÈîÆ] ÂêπÊ≥°Ê≥°  |  Êåâ [Â≠óÊØçÈîÆ] Êà≥Á†¥Ê≥°Ê≥°
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startBtn = document.getElementById('startBtn');
        const loadingText = document.getElementById('loadingText');
        const instruction = document.getElementById('instruction');
        
        const speedSlider = document.getElementById('speedSlider');
        const countSlider = document.getElementById('countSlider');
        const countVal = document.getElementById('countVal');
        const musicBtn = document.getElementById('musicBtn');
        const nameInput = document.getElementById('nameInput');
        
        const scoreDisplay = document.getElementById('scoreDisplay');
        const scoreBoard = document.getElementById('score-board');

        let width, height;
        let bubbles = [];
        let particles = [];
        let ripples = []; 
        let isGameActive = false;
        let score = 0;
        
        let globalSpeedMultiplier = parseFloat(speedSlider.value);
        let spawnQuantity = parseInt(countSlider.value);
        let isSpawning = false;
        let childName = nameInput.value || "ÊÇ†ÊÇ†";
        
        let blowAnimationEnd = 0; 
        
        let currentPraiseInterval = 5; 
        const maxPraiseInterval = 20; 
        let nextPraiseTarget = 5; 
        
        let currentPraiseUtterance = null;
        let lastPlayedLetterSource = null; 
        
        speedSlider.addEventListener('input', (e) => {
            globalSpeedMultiplier = parseFloat(e.target.value);
        });
        
        countSlider.addEventListener('input', (e) => {
            spawnQuantity = parseInt(e.target.value);
            countVal.innerText = spawnQuantity;
        });

        nameInput.addEventListener('input', (e) => {
            childName = e.target.value.trim() || "ÊÇ†ÊÇ†";
        });
        nameInput.addEventListener('keydown', (e) => {
            e.stopPropagation();
        });
        
        let audioCtx;
        let isMusicPlaying = true;
        let musicNextNoteTime = 0;
        let musicTimerID = null;
        let noteIndex = 0;

        // --- Â≠óÊØçÈü≥È¢ëÁ≥ªÁªü (Êú¨Âú∞‰ºòÂÖà -> Web Audio -> HTML5 Audio Hybrid) ---
        const letterAudioMap = {};
        let loadedCount = 0;

        // Âú®Á∫øÈü≥È¢ëÊ∫ê
        function getOnlineSoundUrl(letter) {
            const l = letter.toUpperCase();
            return `https://dict.youdao.com/dictvoice?audio=${l}&type=2`;
        }

        // Êú¨Âú∞Èü≥È¢ëÊé•Âè£ÂÆö‰πâ
        function getLocalSoundUrl(letter) {
            return `./sound/${letter.toLowerCase()}.mp3`;
        }

        // È¢ÑÂä†ËΩΩÈÄªËæëÔºö‰ºòÂÖàÂä†ËΩΩÊú¨Âú∞ sound/x.mp3ÔºåÂ¶ÇÊûúÂ§±Ë¥•ÂàôÂä†ËΩΩÂú®Á∫øÈü≥È¢ë
        function preloadSounds() {
            const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
            
            letters.forEach(letter => {
                const localUrl = getLocalSoundUrl(letter);
                const onlineUrl = getOnlineSoundUrl(letter);

                // 1. Â∞ùËØï Fetch Êú¨Âú∞Êñá‰ª∂
                fetch(localUrl)
                    .then(response => {
                        if (!response.ok) throw new Error("Local file not found");
                        return response.arrayBuffer();
                    })
                    .then(arrayBuffer => {
                        // Êú¨Âú∞Êñá‰ª∂Â≠òÂú®ÔºåËß£Á†Å‰ΩøÁî®
                        if (audioCtx) {
                            return audioCtx.decodeAudioData(arrayBuffer);
                        }
                    })
                    .then(audioBuffer => {
                        if (audioBuffer) {
                            // ‰ΩøÁî® WebAudio Ê†ºÂºèÂ≠òÂÇ®ÔºåÂÆûÁé∞0Âª∂Ëøü
                            // ‰∏∫‰∫ÜÂÖºÂÆπÁªü‰∏ÄÊé•Âè£ÔºåÊàë‰ª¨Êää buffer Â≠òËµ∑Êù•Ôºå
                            // Âπ∂Âú® letterAudioMap ‰∏≠Ê†áËÆ∞ÂÆÉÊòØ‰∏Ä‰∏™ Buffer
                            letterAudioMap[letter] = { type: 'buffer', data: audioBuffer };
                            console.log(`Â∑≤Âä†ËΩΩÊú¨Âú∞ËØ≠Èü≥: ${letter}`);
                            incrementLoad();
                        }
                    })
                    .catch(err => {
                        // 2. Êú¨Âú∞Â§±Ë¥•ÔºåÂõûÈÄÄÂà∞ HTML5 Audio Âä†ËΩΩÂú®Á∫øËµÑÊ∫ê
                        // ËøôÈáå‰ΩøÁî® HTML5 Audio ÂØπË±°ÊòØ‰∏∫‰∫ÜÊõ¥Â•ΩÁöÑÂÖºÂÆπÊÄßÂíåÊµÅÂºèÁºìÂÜ≤
                        const audio = new Audio();
                        audio.src = onlineUrl;
                        audio.preload = "auto"; 
                        
                        letterAudioMap[letter] = { type: 'audio', data: audio };

                        audio.oncanplaythrough = () => {
                            if(!audio.loadedFlag) {
                                audio.loadedFlag = true;
                                incrementLoad();
                            }
                        };
                        
                        audio.onerror = () => {
                            console.warn("Error loading online audio:", letter);
                            // Âç≥‰ΩøÂ§±Ë¥•‰πüËÆ°Êï∞ÔºåÈò≤Ê≠¢Âç°Ê≠ªÂä†ËΩΩÁïåÈù¢
                            if(!audio.loadedFlag) {
                                audio.loadedFlag = true;
                                incrementLoad();
                            }
                        };
                        
                        audio.load();
                    });
            });
        }

        function incrementLoad() {
            loadedCount++;
            loadingText.innerText = `ÂáÜÂ§áÂ≠óÊØçÂ£∞Èü≥... ${loadedCount}/26`;
            if (loadedCount >= 26) {
                onAllSoundsLoaded();
            }
        }

        function onAllSoundsLoaded() {
            startBtn.disabled = false;
            startBtn.innerText = "ÂºÄÂßãÁé©Ê≥°Ê≥°ÔºÅ";
            loadingText.style.display = 'none';
        }

        // Á´ãÂç≥ÂºÄÂßãÂä†ËΩΩ
        preloadSounds();

        // --- Ê†∏ÂøÉÔºöÈü≥È¢ëÈ¢ÑÁÉ≠ (Warm-up) ---
        function warmUpAudio() {
            const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
            letters.forEach(letter => {
                const item = letterAudioMap[letter];
                if (item && item.type === 'audio') {
                    const audio = item.data;
                    audio.muted = true;
                    const playPromise = audio.play();
                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            audio.pause();
                            audio.currentTime = 0;
                            audio.muted = false; 
                        }).catch(e => {});
                    }
                }
            });
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        window.addEventListener('resize', resize);
        resize();

        function ensureAudioContext() {
            if (!audioCtx) {
                try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                } catch(e) {}
            }
            if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
        }

        // --- ËÉåÊôØÈü≥‰πê ---
        const NOTES = {
            'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23,
            'G4': 392.00, 'A4': 440.00, 'B4': 493.88, 'C5': 523.25,
            'D5': 587.33, 'E5': 659.25, 'F5': 698.46, 'G5': 783.99
        };
        const MELODY = [
            'C4', 'E4', 'G4', 'C5', 'G4', 'E4',
            'C4', 'F4', 'A4', 'C5', 'A4', 'F4',
            'B4', 'D5', 'G5', 'D5', 'B4', 'G4',
            'C4', 'E4', 'G4', 'C5', 'G4', 'E4'
        ];

        function playMusicNote(note, time) {
            if (!audioCtx || !isMusicPlaying) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine'; 
            osc.frequency.value = NOTES[note];
            gain.gain.setValueAtTime(0, time);
            gain.gain.linearRampToValueAtTime(0.1, time + 0.05); 
            gain.gain.exponentialRampToValueAtTime(0.001, time + 0.5); 
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start(time);
            osc.stop(time + 0.6);
        }

        function scheduler() {
            if (!isGameActive || !isMusicPlaying) return;
            while (musicNextNoteTime < audioCtx.currentTime + 0.1) {
                playMusicNote(MELODY[noteIndex % MELODY.length], musicNextNoteTime);
                musicNextNoteTime += 0.4; 
                noteIndex++;
            }
            musicTimerID = requestAnimationFrame(scheduler);
        }

        function startMusic() {
            ensureAudioContext();
            if (isMusicPlaying) {
                musicNextNoteTime = audioCtx.currentTime + 0.1;
                noteIndex = 0;
                scheduler();
                musicBtn.innerText = "üéµ";
                musicBtn.style.opacity = "1";
            } else {
                musicBtn.innerText = "üîá";
                musicBtn.style.opacity = "0.5";
            }
        }

        musicBtn.addEventListener('click', () => {
            isMusicPlaying = !isMusicPlaying;
            if (isMusicPlaying) {
                musicBtn.innerText = "üéµ";
                musicBtn.style.opacity = "1";
                musicNextNoteTime = audioCtx.currentTime + 0.1; 
                scheduler();
            } else {
                musicBtn.innerText = "üîá";
                musicBtn.style.opacity = "0.5";
                cancelAnimationFrame(musicTimerID);
            }
        });

        // --- Ê∏∏ÊàèÈü≥Êïà ---
        function playPopSound(letter) {
            if (!audioCtx) return;
            const t = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine';
            const index = (letter || 'A').toUpperCase().charCodeAt(0) - 65;
            const safeIndex = Math.max(0, Math.min(25, index));
            const startFreq = 1046.5 * Math.pow(2, -safeIndex / 12);
            osc.frequency.setValueAtTime(startFreq, t);
            osc.frequency.exponentialRampToValueAtTime(10, t + 0.15);
            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(0.8, t + 0.005); 
            gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1); 
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start(t);
            osc.stop(t + 0.15);
        }

        function playBlowSound() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(100, audioCtx.currentTime);
            osc.frequency.linearRampToValueAtTime(300, audioCtx.currentTime + 0.3);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.3);
        }

        function speakLetter(letter) {
            const item = letterAudioMap[letter];
            
            if (item) {
                if (item.type === 'buffer' && audioCtx) {
                    // Êú¨Âú∞È´òË¥®ÈáèÈü≥È¢ë (Web Audio)
                    if (lastPlayedLetterSource) {
                        try { lastPlayedLetterSource.stop(); } catch(e) {}
                    }
                    const source = audioCtx.createBufferSource();
                    source.buffer = item.data;
                    source.connect(audioCtx.destination);
                    lastPlayedLetterSource = source;
                    source.start(0);
                } else if (item.type === 'audio') {
                    // Âú®Á∫øÈü≥È¢ë (HTML5 Audio)
                    const audio = item.data;
                    audio.currentTime = 0;
                    audio.play().catch(e => {});
                }
            } else {
                // Fallback: TTS
                if ('speechSynthesis' in window) {
                    window.speechSynthesis.cancel(); 
                    const utterance = new SpeechSynthesisUtterance(letter);
                    utterance.lang = 'en-US'; 
                    // ÂØªÊâæÂ•≥Â£∞
                    const voices = window.speechSynthesis.getVoices();
                    const femaleVoice = voices.find(v => 
                        v.lang.startsWith('en') && 
                        (v.name.includes('Google US English') || v.name.includes('Zira') || v.name.includes('Samantha') || v.name.toLowerCase().includes('female'))
                    );
                    if (femaleVoice) utterance.voice = femaleVoice;
                    window.speechSynthesis.speak(utterance);
                }
            }
        }

        // --- Êô∫ËÉΩÂ§∏ËµûÁ≥ªÁªü ---
        
        let hasNaturalVoice = false;
        let bestLocalVoice = null;
        
        const DB_NAME = 'BubbleGameAudioCache';
        const DB_VERSION = 1;
        const STORE_NAME = 'praises';
        let db = null;

        function initDB() {
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            request.onerror = (event) => console.error("Database error: " + event.target.errorCode);
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(STORE_NAME)) {
                    db.createObjectStore(STORE_NAME);
                }
            };
            request.onsuccess = (event) => {
                db = event.target.result;
            };
        }
        
        function getCachedAudio(text, callback) {
            if (!db) { callback(null); return; }
            const transaction = db.transaction([STORE_NAME], "readonly");
            const objectStore = transaction.objectStore(STORE_NAME);
            const request = objectStore.get(text);
            request.onsuccess = (event) => {
                if (request.result) callback(request.result);
                else callback(null);
            };
            request.onerror = () => callback(null);
        }

        function cacheAudio(text, blob) {
            if (!db) return;
            const transaction = db.transaction([STORE_NAME], "readwrite");
            const objectStore = transaction.objectStore(STORE_NAME);
            objectStore.put(blob, text);
        }

        initDB();

        if ('speechSynthesis' in window) {
            window.speechSynthesis.onvoiceschanged = scanLocalVoices;
            setTimeout(scanLocalVoices, 100);
        }

        function scanLocalVoices() {
             if (!('speechSynthesis' in window)) return;
             const voices = window.speechSynthesis.getVoices();
             let bestScore = -1;
             
             voices.forEach(v => {
                if (v.lang.includes('zh') || v.lang.includes('CN') || v.lang.includes('TW')) {
                    let score = 0;
                    const name = v.name.toLowerCase();
                    if (name.includes('microsoft') && name.includes('natural')) score = 100;
                    else if (name.includes('google')) score = 90;
                    else if (name.includes('apple')) score = 85;
                    else if (name.includes('microsoft')) score = 60;
                    else score = 10;
                    if (v.lang === 'zh-CN') score += 5;
                    if (score > bestScore) {
                        bestScore = score;
                        bestLocalVoice = v;
                    }
                }
            });
            
            if (bestLocalVoice) {
                hasNaturalVoice = (bestScore >= 80);
            }
        }

        function playMagicSound() {
            if (!audioCtx) return;
            const now = audioCtx.currentTime;
            const notes = [523.25, 659.25, 783.99, 987.77, 1046.50]; 
            notes.forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.value = freq;
                const startTime = now + i * 0.05;
                gain.gain.setValueAtTime(0, startTime);
                gain.gain.linearRampToValueAtTime(0.3, startTime + 0.05);
                gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.5);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start(startTime);
                osc.stop(startTime + 0.5);
            });
        }

        const praiseTemplates = [
            "ÂìáÔºå{name}Â∑≤ÁªèÊî∂ÈõÜ‰∫Ü{n}‰∏™Ê≥°Ê≥°Âï¶ÔºÅ",
            "Â§™Ê£í‰∫ÜÔºå{name}Êî∂ÈõÜ‰∫Ü{n}‰∏™Áæé‰∏ΩÁöÑÊ≥°Ê≥°ÔºÅ",
            "Â•ΩÂéâÂÆ≥Ôºå{name}ËÆ©{n}‰∏™Ê≥°Ê≥°ÂèòÊàê‰∫ÜÁÉüËä±ÔºÅ",
            "{name}ÁúüÊ£íÔºåÊàë‰ª¨Â∑≤ÁªèËÆ§ËØÜ‰∫Ü{n}‰∏™Ê≥°Ê≥°ÊúãÂèãÔºÅ",
            "Âä†Ê≤πÂä†Ê≤πÔºå{name}Â∑≤ÁªèÊî∂ÈõÜ‰∫Ü{n}‰∏™Ê≥°Ê≥°Âï¶ÔºÅ",
            "{name}ÂÅöÂæóÂ•ΩÔºå‰Ω†Â∑≤ÁªèÊî∂ÈõÜ‰∫Ü{n}‰∏™Ê≥°Ê≥°ÔºÅ"
        ];

        function speakPraise(count) {
            playMagicSound();
            const templateIndex = Math.floor(Math.random() * praiseTemplates.length);
            const template = praiseTemplates[templateIndex];
            const text = template.replace("{n}", count).replace("{name}", childName);

            // 1. „ÄêÊñ∞Â¢û„Äë‰ºòÂÖàÂ∞ùËØïÂä†ËΩΩÊú¨Âú∞Ëá™ÂÆö‰πâÈºìÂä±ËØ≠Èü≥
            // Êñá‰ª∂ÂêçÁ∫¶ÂÆöÔºöpraise_0.mp3 ÂØπÂ∫îÁ¨¨‰∏ÄÂè•, praise_1.mp3 ÂØπÂ∫îÁ¨¨‰∫åÂè•...
            const localPraiseUrl = `./sound/praise_${templateIndex}.mp3`;
            
            fetch(localPraiseUrl)
                .then(res => {
                    if (!res.ok) throw new Error("Local praise missing");
                    return res.blob();
                })
                .then(blob => {
                    console.log("Playing LOCAL praise file:", localPraiseUrl);
                    const url = URL.createObjectURL(blob);
                    const audio = new Audio(url);
                    audio.play();
                })
                .catch(() => {
                    // 2. Â¶ÇÊûúÊú¨Âú∞Ê≤°ÊúâÔºåÂõûÈÄÄÂà∞ÂéüÊúâÈÄªËæë (DBÁºìÂ≠ò -> Âú®Á∫øTTS -> Êú¨Âú∞TTS)
                    playFallbackPraise(text);
                });
        }

        function playFallbackPraise(text) {
            getCachedAudio(text, (blob) => {
                if (blob) {
                    const url = URL.createObjectURL(blob);
                    const audio = new Audio(url);
                    audio.play().catch(e => console.error("Cache play failed", e));
                    return;
                }

                if (hasNaturalVoice && bestLocalVoice) {
                    speakNativeTTS(text);
                    return;
                }

                const encodedText = encodeURIComponent(text);
                const audioSources = [
                    `https://fanyi.sogou.com/reventondc/synthesis?text=${encodedText}&speed=1&lang=zh-CHS&from=translateweb&speaker=6`,
                    `https://dict.youdao.com/dictvoice?audio=${encodedText}&le=zh`
                ];
                tryFetchAndCache(audioSources, 0, text);
            });
        }

        function tryFetchAndCache(sources, index, text) {
            if (index >= sources.length) {
                speakNativeTTS(text);
                return;
            }

            const url = sources[index];
            
            fetch(url)
                .then(response => {
                    if (!response.ok) throw new Error("Network error");
                    return response.blob();
                })
                .then(blob => {
                    const audioUrl = URL.createObjectURL(blob);
                    const audio = new Audio(audioUrl);
                    audio.play().catch(e => console.error("Play failed", e));
                    cacheAudio(text, blob);
                })
                .catch(err => {
                    tryDirectPlay(url, sources, index, text);
                });
        }

        function tryDirectPlay(url, sources, index, text) {
            const audio = new Audio(url);
            
            const timeoutId = setTimeout(() => {
                audio.src = "";
                tryFetchAndCache(sources, index + 1, text); 
            }, 1000);

            audio.oncanplaythrough = () => {
                clearTimeout(timeoutId);
                audio.play().catch(() => {});
            };

            audio.onerror = () => {
                clearTimeout(timeoutId);
                tryFetchAndCache(sources, index + 1, text);
            };
        }

        function speakNativeTTS(text) {
            if (!('speechSynthesis' in window)) return;
            window.speechSynthesis.cancel(); 

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'zh-CN'; 
            currentPraiseUtterance = utterance; 
            utterance.onend = function() { currentPraiseUtterance = null; };
            
            if (bestLocalVoice) {
                utterance.voice = bestLocalVoice;
                if (hasNaturalVoice) {
                    utterance.rate = 1.0; utterance.pitch = 1.0;
                } else {
                    utterance.rate = 0.95; utterance.pitch = 1.1; 
                }
            }
            window.speechSynthesis.speak(utterance);
        }

        // --- Ê∏∏ÊàèÂØπË±° ---

        class Bubble {
            constructor(letter, startX, startY) {
                this.r = 30 + Math.random() * 40; 
                this.x = startX !== undefined ? startX : Math.random() * width;
                this.y = startY !== undefined ? startY : height + this.r;
                this.baseSpeed = 1 + Math.random() * 2; 
                if (startX !== undefined) this.vx = (Math.random() - 0.5) * 8; 
                else this.vx = 0;
                this.sway = Math.random() * 0.05;
                this.swayOffset = Math.random() * Math.PI * 2;
                this.colorHue = Math.random() * 360;
                this.letter = letter || String.fromCharCode(65 + Math.floor(Math.random() * 26)); 
                this.popped = false;
            }

            update() {
                this.y -= this.baseSpeed * globalSpeedMultiplier;
                if (this.vx !== 0) { this.x += this.vx; this.vx *= 0.98; }
                this.x += Math.sin(this.y * this.sway + this.swayOffset) * 1.5;
                
                if (this.x - this.r < 0) { this.x = this.r; this.vx = Math.abs(this.vx) * 0.5 + 0.5; } 
                else if (this.x + this.r > width) { this.x = width - this.r; this.vx = -Math.abs(this.vx) * 0.5 - 0.5; }

                if (this.y < -this.r * 2) { this.popped = true; return false; }
                return true;
            }

            draw() {
                ctx.save();
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                ctx.fillStyle = `hsla(${this.colorHue}, 100%, 75%, 0.4)`;
                ctx.fill();
                ctx.strokeStyle = `hsla(${this.colorHue}, 100%, 85%, 0.8)`;
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(this.x - this.r * 0.3, this.y - this.r * 0.3, this.r * 0.2, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.font = `bold ${this.r}px "Comic Sans MS", "Verdana", sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = 'rgba(0,0,0,0.3)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                ctx.fillText(this.letter, this.x, this.y + this.r * 0.1);
                ctx.restore();
            }
        }

        class Ripple {
            constructor(x, y, hue) {
                this.x = x; this.y = y; this.r = 10; this.hue = hue;
                this.opacity = 0.8; this.life = 1.0;
            }
            update() { this.r += 4; this.opacity -= 0.04; this.life -= 0.04; }
            draw() {
                ctx.save();
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                ctx.strokeStyle = `hsla(${this.hue}, 100%, 80%, ${this.opacity})`;
                ctx.lineWidth = 5 * this.life;
                ctx.stroke();
                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, hue, shapeType) {
                this.x = x; this.y = y; this.shapeType = shapeType; 
                this.hue = hue; this.life = 1.0; this.size = Math.random() * 6 + 3;
                const angle = Math.random() * Math.PI * 2; let speed = Math.random() * 6 + 2;
                
                switch(shapeType) {
                    case 0: this.vx = (Math.random() - 0.5) * 6; this.vy = (Math.random() - 1) * 10 - 2; this.gravity = 0.5; this.drag = 0.98; this.decay = 0.02; break;
                    case 1: speed = Math.random() * 8 + 4; this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed; this.gravity = 0.1; this.drag = 0.95; this.decay = 0.015; break;
                    case 2: speed = Math.random() * 4 + 1; this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed; this.gravity = 0.05; this.drag = 0.90; this.decay = 0.01; this.swayPhase = Math.random() * Math.PI * 2; break;
                    case 3: speed = Math.random() * 5 + 2; this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed; this.gravity = 0; this.drag = 0.97; this.decay = 0.02; break;
                    case 4: this.vx = (Math.random() - 0.5) * 4; this.vy = (Math.random() - 0.5) * 4 - 2; this.gravity = -0.05; this.drag = 0.95; this.decay = 0.015; break;
                    default: this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed; break;
                }
                this.rotation = Math.random() * Math.PI * 2; this.rotationSpeed = (Math.random() - 0.5) * 0.2;
            }

            update() {
                if (this.shapeType === 2) this.x += Math.sin(this.life * 10 + this.swayPhase) * 1.5;
                if (this.shapeType === 3) { const s = 0.15; const oldVx = this.vx; this.vx = this.vx * Math.cos(s) - this.vy * Math.sin(s); this.vy = oldVx * Math.sin(s) + this.vy * Math.cos(s); }
                this.x += this.vx; this.y += this.vy;
                this.vx *= this.drag; this.vy *= this.drag; this.vy += this.gravity;
                this.life -= this.decay; this.size *= 0.96; this.rotation += this.rotationSpeed;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y); ctx.rotate(this.rotation);
                ctx.globalAlpha = this.life; ctx.globalCompositeOperation = 'lighter';
                ctx.fillStyle = `hsl(${this.hue}, 100%, 70%)`;
                switch(this.shapeType) {
                    case 1: this.drawStar(0, 0, 5, this.size, this.size/2); break;
                    case 2: ctx.fillRect(-this.size, -this.size, this.size*2, this.size*2); break;
                    case 3: this.drawTriangle(0, 0, this.size); break;
                    case 4: this.drawHeart(0, 0, this.size); break;
                    default: ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI * 2); ctx.fill(); break;
                }
                ctx.restore();
            }

            drawTriangle(cx, cy, size) { ctx.beginPath(); ctx.moveTo(0, -size); ctx.lineTo(size, size); ctx.lineTo(-size, size); ctx.closePath(); ctx.fill(); }
            drawHeart(cx, cy, size) { const s = size * 0.8; ctx.beginPath(); ctx.moveTo(0, 0); ctx.bezierCurveTo(s/2, -s/2, s*2, s/3, 0, s*1.5); ctx.bezierCurveTo(-s*2, s/3, -s/2, -s/2, 0, 0); ctx.fill(); }
            drawStar(cx, cy, spikes, outerRadius, innerRadius) { let rot = Math.PI / 2 * 3; let x = cx; let y = cy; let step = Math.PI / spikes; ctx.beginPath(); ctx.moveTo(cx, cy - outerRadius); for (let i = 0; i < spikes; i++) { x = cx + Math.cos(rot) * outerRadius; y = cy + Math.sin(rot) * outerRadius; ctx.lineTo(x, y); rot += step; x = cx + Math.cos(rot) * innerRadius; y = cy + Math.sin(rot) * innerRadius; ctx.lineTo(x, y); rot += step; } ctx.lineTo(cx, cy - outerRadius); ctx.closePath(); ctx.fill(); }
        }

        function drawWand() {
            const centerX = width / 2;
            const bottomY = height + 10; 
            let scale = 1; let wobble = 0; const now = Date.now();
            if (now < blowAnimationEnd) { const progress = (blowAnimationEnd - now) / 500; scale = 1 + Math.sin(progress * Math.PI) * 0.2; wobble = Math.sin(progress * Math.PI * 8) * 0.05; }
            ctx.save(); ctx.translate(centerX, bottomY); ctx.rotate(wobble); ctx.scale(scale, scale);
            ctx.fillStyle = '#FF8A80'; ctx.beginPath(); ctx.roundRect(-8, -150, 16, 160, 8); ctx.fill();
            ctx.strokeStyle = 'white'; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(-4, -140); ctx.lineTo(-4, -20); ctx.stroke();
            ctx.translate(0, -150);
            ctx.beginPath(); ctx.arc(0, 0, 45, 0, Math.PI * 2); ctx.strokeStyle = '#FF5252'; ctx.lineWidth = 12; ctx.stroke();
            ctx.beginPath(); ctx.arc(-20, -20, 10, Math.PI, 1.5 * Math.PI); ctx.strokeStyle = 'rgba(255,255,255,0.6)'; ctx.lineWidth = 4; ctx.stroke();
            if (now < blowAnimationEnd) { ctx.beginPath(); ctx.arc(0, 0, 38, 0, Math.PI * 2); ctx.fillStyle = 'rgba(200, 240, 255, 0.4)'; ctx.fill(); }
            ctx.restore();
        }

        function startGame() {
            if (isGameActive) return; 
            startBtn.style.display = 'none';
            instruction.classList.remove('hidden');
            instruction.style.display = 'block';
            isGameActive = true;
            ensureAudioContext();
            startMusic(); 
            scanLocalVoices(); 
            warmUpAudio(); 
            spawnBubbles(spawnQuantity); 
            gameLoop();
        }

        function spawnBubbles(count) {
            isSpawning = true;
            playBlowSound();
            blowAnimationEnd = Date.now() + 800;
            const startX = width / 2;
            const startY = height - 140; 
            for (let i = 0; i < count; i++) {
                setTimeout(() => {
                    const activeLetters = new Set(bubbles.filter(b => !b.popped).map(b => b.letter));
                    const allLetters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
                    const available = allLetters.filter(l => !activeLetters.has(l));
                    let finalLetter = available.length > 0 ? available[Math.floor(Math.random() * available.length)] : allLetters[Math.floor(Math.random() * allLetters.length)];
                    bubbles.push(new Bubble(finalLetter, startX, startY));
                    if (i === 0) isSpawning = false;
                }, i * 60); 
            }
        }

        function popBubble(letter) {
            const candidates = bubbles.filter(b => b.letter === letter && !b.popped);
            if (candidates.length > 0) {
                const target = candidates[Math.floor(Math.random() * candidates.length)];
                target.popped = true;
                score++;
                scoreDisplay.innerText = score;
                scoreBoard.style.transform = "scale(1.2)";
                setTimeout(() => scoreBoard.style.transform = "scale(1)", 150);
                ripples.push(new Ripple(target.x, target.y, target.colorHue));
                const charCode = target.letter.charCodeAt(0);
                const shapeType = (charCode - 65) % 5;
                for (let i = 0; i < 25; i++) { particles.push(new Particle(target.x, target.y, target.colorHue, shapeType)); }
                showFloatingText(target.letter, target.x, target.y);
                playPopSound(target.letter);
                speakLetter(letter);
                
                if (score >= nextPraiseTarget) {
                    speakPraise(nextPraiseTarget);
                    if (currentPraiseInterval < maxPraiseInterval) currentPraiseInterval += 5; 
                    nextPraiseTarget += currentPraiseInterval;
                }
                return true;
            }
            return false;
        }

        function showFloatingText(text, x, y) {
            const el = document.createElement('div'); el.className = 'pop-text'; el.innerText = text;
            el.style.left = x + 'px'; el.style.top = y + 'px'; document.body.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }

        function gameLoop() {
            if (!isGameActive) return;
            const activeBubbles = bubbles.filter(b => !b.popped);
            if (activeBubbles.length === 0 && !isSpawning) {
                isSpawning = true; 
                setTimeout(() => {
                    const currentActive = bubbles.filter(b => !b.popped);
                    if(currentActive.length === 0) spawnBubbles(spawnQuantity);
                    else isSpawning = false;
                }, 500);
            }
            ctx.clearRect(0, 0, width, height);
            drawWand();
            for (let i = bubbles.length - 1; i >= 0; i--) { const b = bubbles[i]; const keep = b.update(); if (!keep || b.popped) bubbles.splice(i, 1); else b.draw(); }
            for (let i = ripples.length - 1; i >= 0; i--) { const r = ripples[i]; r.update(); if (r.life <= 0) ripples.splice(i, 1); else r.draw(); }
            for (let i = particles.length - 1; i >= 0; i--) { const p = particles[i]; p.update(); if (p.life <= 0) particles.splice(i, 1); else p.draw(); }
            requestAnimationFrame(gameLoop);
        }

        startBtn.addEventListener('click', startGame);
        window.addEventListener('keydown', (e) => {
            if (!isGameActive && e.code === 'Space' && !startBtn.disabled) { e.preventDefault(); startGame(); return; }
            if (!isGameActive) return;
            if (e.code === 'Space') { e.preventDefault(); spawnBubbles(spawnQuantity); }
            const key = e.key.toUpperCase();
            if (key.length === 1 && key >= 'A' && key <= 'Z') popBubble(key);
        });
        window.addEventListener('touchstart', (e) => {
            if(!isGameActive) return;
            if(e.target === nameInput) return;
            if(!e.target.closest('#controls') && e.target !== startBtn) spawnBubbles(spawnQuantity); 
        });
    </script>
</body>
</html>